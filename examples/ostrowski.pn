#load("ostrowski/add_2.txt", "pecan", add2(alpha, a, b, c))
#load("ostrowski/recog_2.txt", "pecan", recog2(alpha, x))
#load("ostrowski/all_ones_2.txt", "pecan", all_ones2(a))
#load("sturmian2.txt", "pecan", sturmian(n))

x is ostrowski(a) := x is finite_num & recog2(a, x)

#type(ostrowski(a), {
    "adder": add2(a, any, any, any),
    "less": lt2(any, any)
})

x is zeckendorf := exists alpha is all_ones2. x is ostrowski(alpha)
zeck_add(a, b, c) := exists alpha is all_ones2. add2(alpha, a, b, c)

#type(zeckendorf, {
    "adder": zeck_add(any, any, any),
    "less": lt2(any, any)
})

x, y, z are ostrowski(alpha)

// These tests of arithmetic properties are relevant because they use bases other than binary
add_comm() := forall alpha. forall x. forall y. x + y = y + x
#assert_prop(true, add_comm)

zero_add_refl() := forall alpha. forall x. x + 0 = x
#assert_prop(true, zero_add_refl)

add_assoc_const() := forall alpha. forall x. x + (1 + 1) = (x + 1) + 1
#assert_prop(true, add_assoc_const)

add_assoc() := forall alpha. forall x. forall y. forall z. exists yz is ostrowski(alpha). yz = y + z & exists xy is ostrowski(alpha). xy = x + y & x + yz = xy + z
#assert_prop(true, add_assoc)

i, j, k, n are zeckendorf

// The Fibonacci word (i.e., characteristic Sturmian word with slope = 1/phi)
F(n) := sturmian(n)

// TODO: Make this nicer
square(i, n) := i is zeckendorf & n is zeckendorf & n > 0 & !(exists k. k < n & (exists ik is zeckendorf. ik = i + k & exists ikn is zeckendorf. ikn = ik + n & !(F(ik) <=> F(ikn))))
squares_exist() := exists i. exists n. square(i, n)
#assert_prop(true, squares_exist)

cube(i, n) := square(i, n) & square(i + n, n)
cubes_exist() := exists i. exists n. cube(i, n)
#assert_prop(true, cubes_exist)

fourth_power(i, n) := square(i, n) & exists in is zeckendorf. in = i + n & square(in, n) & square(in + n, n)
fourth_power_exist() := exists i. exists n. fourth_power(i, n)
#assert_prop(false, fourth_power_exist)

