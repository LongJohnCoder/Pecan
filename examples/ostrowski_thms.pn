#import("ostrowski_defs.pn")

#load("ostrowski/sturmian_word.txt", "pecan", $C(n))

Alias "Theorem" ==> Execute uncurry theoremCheck .

eventually_periodic(a, p) := @no_simplify[
    bco_valid(a,p) &
    exists z. bco_zero(z) & bco_lt(z, p) &
    exists n. bco_valid(a, n) &
    forall i, ip.
        (bco_adder(a,i,p,ip) & bco_valid(a,n) & bco_leq(n,i))
        =>
        $C[i] = $C[ip]
    ]
// Theorem ("'Sturmian words are not eventually periodic'", {
//     forall a, p. bco_valid(a, p) => !eventually_periodic(a, p)
// }) .

// Theorem ("'Sturmian words start with arbitrarily long squares'", {
//     @no_simplify[
//         forall a. bco_standard(a) =>
//         forall n is ostrowski(a).
//         exists m is ostrowski(a). m > n &
//         forall j, jm. (bco_lt(j,m) & bco_adder(a,j,m,jm)) => $C[j] = $C[jm]
//     ]
// }) .

bco_positive(x) := @simplify[exists z. bco_zero(z) & bco_lt(z, x)]

square(a, n) :=
    @no_simplify[
        exists i.
        @postprocess[bco_valid2(a, i, n) &
        @postprocess[forall bound.
        @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
        @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
            @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] = $C[jn]]]])]]]
    ]
#save_aut("square.aut", square)

// #load("square.aut", "hoa", square(a,n))

Theorem ("'All Sturmian words contain squares'", {
    @no_simplify[
        forall a. bco_standard(a) => exists n. bco_positive(n) & bco_valid(a,n) & square(a,n)
    ]
}) .

