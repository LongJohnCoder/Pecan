// TODO: Would be nice to have some sort of custom pretty-printer thing so that we can translate from encodings into something that's actually readable (e.g., for accepting words)
//  Once we implement a real programming language for Pecan, we should be able to do this fairly easily?

#load("real/msd_bin_add.txt", "pecan", msd_bin_add(a, b, c))
#load("real/msd_bin_less.txt", "labeled", msd_bin_less(a, b))
#load("real/real_equal.txt", "labeled", real_equal(a, b))

one_int(x) := "!x & X(x) & X(X(G(!x)))"
zeros(x) := "G(!x)"

not_all_ones(x) := "G(F(!x))"

any2(a, b) := true

// Build the basic recognition, addition, and comparison operators for real numbers
#shuffle(int(x), any(x), real(x))
#shuffle(one_int(x), zeros(x), real_one(x))

// TODO: Add a "postprocess everything" option in the context or something; this would be helpful for when we want to produce minimally sized automata and can afford to pay the time cost
#shuffle(int_less(a, b), any2(a, b), integral_less(a, b))

equal_int(a is int, b is int) := a = b
#shuffle(equal_int(a, b), any2(a, b), integral_equal(a, b))

integral_less_irrefl() := forall x is real. !integral_less(x, x)
#assert_prop(true, integral_less_irrefl)

integral_less_antisym() := forall x is real. forall y is real. if integral_less(x, y) & integral_less(y, x) then integral_equal(x, y)
#assert_prop(true, integral_less_antisym)

integral_less_trans() := forall x is real. forall y is real. forall z is real. if integral_less(x, y) & integral_less(y, z) then integral_less(x, z)
#assert_prop(true, integral_less_trans)

// TODO: Probably writing "a is int" in the argument should automatically add a "a is int" conjunction to the body. That would make sense, anyway, and it would reduce the repetitions we have in some predicates about. We should also grab restrictions from the environment when we do this (or just look at the restriction_env, probably)
ints2(a is int, b is int) := a is int & b is int
#shuffle(ints2(a, b), msd_bin_less(a, b), fractional_less(a, b))

fractional_less_irrefl() := forall x is any. !fractional_less(x, x)
#assert_prop(true, fractional_less_irrefl)

fractional_less_antisym() := forall x is any. forall y is any. if fractional_less(x, y) & fractional_less(y, x) then x = y
#assert_prop(true, fractional_less_antisym)

fractional_less_trans() := forall x is any. forall y is any. forall z is any. if fractional_less(x, y) & fractional_less(y, z) then fractional_less(x, z)
#assert_prop(true, fractional_less_trans)

to_zero(a, b) := zeros(b)

#shuffle(equal_int(a, b), to_zero(a, b), floor(a, b))
#shuffle(to_zero(a, b), default_equal(a, b), fractional_part(a, b))

x, y, z are real

real_equal_refl() := forall x. real_equal(x, x)
#assert_prop(true, real_equal_refl)

real_equal_sym() := forall x. forall y. real_equal(x, y) <=> real_equal(y, x)
#assert_prop(true, real_equal_sym)

real_equal_trans() := forall x. forall y. forall z. (real_equal(x, y) & real_equal(y, z)) => real_equal(x, z)
#assert_prop(true, real_equal_trans)

real_less(a, b) := (!real_equal(a, b)) & (integral_less(a, b) | (integral_equal(a, b) & fractional_less(a, b)))

real_less_irrefl() := forall x. !real_less(x, x)
#assert_prop(true, real_less_irrefl)

real_less_antisym() := forall x. forall y. if real_less(x, y) & real_less(y, x) then real_equal(x, y)
#assert_prop(true, real_less_antisym)

real_less_trans() := forall x. forall y. forall z. if real_less(x, y) & real_less(y, z) then real_less(x, z)
#assert_prop(true, real_less_trans)

real_less_total() := forall x. forall y. real_less(x, y) | real_equal(x, y) | real_less(y, x)
#assert_prop(true, real_less_total)

#load("real/real_add_pos.txt", "labeled", real_add_pos(a, b, c))

x is pos_real := x is real & x is positive

real_add_pos_closed() := forall x. x is positive => forall y. y is positive => exists z. real_add_pos(x, y, z)
#assert_prop(true, real_add_pos_closed)

real_add_pos_comm() := forall x. x is positive => forall y. y is positive => exists z. (real_add_pos(x, y, z) <=> real_add_pos(y, x, z))
#assert_prop(true, real_add_pos_comm)

real_add_pos_assoc() := forall x. x is positive =>
                        forall y. y is positive =>
                        forall z. z is positive =>
                        exists w is real.
                        exists xy is real. real_add_pos(x, y, xy) &
                        exists yz is real. real_add_pos(y, z, yz) &
                            (real_add_pos(xy, z, w) <=> real_add_pos(x, yz, w))
// #assert_prop(true, real_add_pos_assoc)

real_sub_pos(a, b, c) := real_add_pos(c, b, a)

can_sub_if_lt() := forall x. x is positive => forall y. y is positive & real_less(y, x) => exists w. real_add_pos(w, y, x)
#assert_prop(true, can_sub_if_lt)

// can_sub_if_lt_fail(x, y) := x is real & x is positive & y is real & y is positive & real_less(y, x) & !(exists w. real_add_pos(w, y, x))
// #accepting_word(can_sub_if_lt_fail)

// #save_aut_img("real_add_pos.svg", real_add_pos)

// test_val(x) := "!x & X(x) & X(X(!x)) & X(X(X(x))) & X(X(X(X(G(!x)))))"
// #save_aut_img("test_val.svg", test_val)

// #load("can_sub_if_lt_fail.aut", "hoa", fail_pair_sub(x, y))
// test10(k) := exists z. exists y. test_val(z) & exists x. fail_pair_sub(x, y) & real_add_pos(z, y, k)
// #save_aut_img("test10.svg", test10)
// #accepting_word(test10)

pos_real_add(a, b, c) := positive(a) & positive(b) & real_add_pos(a, b, c)
neg_real_add(a, b, c) := negative(a) & negative(b) & negate(real_add_pos(negate(a), negate(b)), c)
neg_pos_real_add(a, b, c) := (negative(a) & positive(b) & real_less(b, negate(a)) & negate(real_add_pos(_, b, negate(a)), c)) |
                             (negative(a) & positive(b) & (real_less(negate(a), b) | real_equal(negate(a), b)) & real_add_pos(c, negate(a), b))

pos_neg_real_add(a, b, c) := (positive(a) & negative(b) & real_less(a, negate(b)) & negate(real_add_pos(_, a, negate(b)), c)) |
                             (positive(a) & negative(b) & (real_less(negate(b), a) | real_equal(negate(b), a)) & real_add_pos(c, negate(b), a))
real_add(a, b, c) := (pos_real_add(a, b, c) | neg_real_add(a, b, c) | neg_pos_real_add(a, b, c) | pos_neg_real_add(a, b, c))

// add_closed_real_fail(x, y) := real_less(y, negate(x)) & x is real & x is negative & y is real & y is positive & forall z. !neg_pos_real_add(x, y, z)
// #save_aut_img("add_closed_real_fail.svg", add_closed_real_fail)
// // #save_aut("add_closed_real_fail.aut", add_closed_real_fail)
// #accepting_word(add_closed_real_fail)

// #load("add_closed_real_fail.aut", "hoa", fail_pair(x, y))
// test(x, y, c) := fail_pair(x, y) & exists w is real. exists z is real. real_equal(c, w) & real_equal(z, negate(x)) & real_add_pos(w, y, z)
// #accepting_word(test)

#type(real, {
    "adder": real_add(any, any, any),
    "less": real_less(any, any),
    "equal": real_equal(any, any),
    "one": real_one(any)
})

// two(x is real) := real_add(real_one(), real_one(), x)
// // #save_aut_img("two.svg", two)

// add_closed_real() := forall x. forall y. exists z. real_add(x, y, z)
// #assert_prop(true, add_closed_real)

// // problem_val(x) := "!x & X(!x) & X(X(!x)) & X(X(X(!x))) & X(X(X(X(G((!x -> X(x)) & (x -> X(!x)))))))"
// // #accepting_word(problem_val)

// // test2() := problem_val() is real
// // #assert_prop(true, test2)

// // problem_fractional(x) := "!x & X(!x) & X(X(G(x)))"
// // #accepting_word(problem_fractional)

// // sfrac(z) := msd_bin_add(problem_fractional(), problem_fractional(), z)
// // #save_aut_img("sfrac.svg", sfrac)
// // #save_aut("sfrac.aut", sfrac)
// // #accepting_word(sfrac)

// // s(z) := real_add_pos_temp(problem_val(), problem_val(), z)
// // #save_aut_img("s.svg", s)
// // #save_aut("s.aut", s)
// // #accepting_word(s)

// // test(x, z) := x is real & real_add(x, x, z)
// // #save_aut_img("test.svg", test)
// // #save_aut("test.aut", test)
// // #accepting_word(test)

// // test6() := exists x. real_equal(one_half(), x) & add_closed_real_fail(x)
// // #assert_prop(true, test6)

// // add_comm_real() := forall x. forall y. x + y = y + x
// // #assert_prop(true, add_comm_real)

// // add_comm_fail(x is real, y is real) := x is real & y is real & x + y != y + x
// // #save_aut_img("add_comm_fail.svg", add_comm_fail)

// // #accepting_word(add_comm_fail)

