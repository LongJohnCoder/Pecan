#load("bin_add.aut", "hoa", bin_add(a, b, c))
#load("bin_less.aut", "hoa", bin_less(a, b))
#load("odd_ones.aut", "hoa", odd_ones(a))

finite_num(x) := "F(G(!x))"
zero(x) := "G(!x)"

x is any := true
x is nat := finite_num(x)
// binary is, for the moment, a synonym for nat; eventually we may decouple the two
x is binary := finite_num(x)

x is binary
bin_even(x) := x is binary & exists y is binary. x = 2*y
bin_odd(x) := x is binary & Â¬bin_even(x)
#forget(x)

bin_one(x is binary) := x > 0 & forall b is binary. b > 0 => (x <= b)

default_equal(x, y) := "G((x -> y) & (y -> x))"

#context("adder", "bin_add")
#context("less", "bin_less")
#context("one", "bin_one")
#context("equal", "default_equal")

#type(nat, {
    "adder": bin_add(any, any, any),
    "less": bin_less(any, any),
    "one": bin_one(any),
    "even": bin_even(any),
    "equal": default_equal(any, any),
    "odd": bin_odd(any)
})

#type(binary, {
    "adder": bin_add(any, any, any),
    "less": bin_less(any, any),
    "one": bin_one(any),
    "equal": default_equal(any, any),
    "even": bin_even(any),
    "odd": bin_odd(any)
})

Define enumFromTo low high :=
    if low > high then
        []
    else
        low :: enumFromTo (low + 1) high .

Define map f l :=
    match l with
    case [] -> []
    case x :: xs -> f x :: map f xs
    end.

// Define foldl f init xs :=
//     match xs with


Define concatenate xs :=
    match xs with
    case [] -> ""
    case x :: xs -> toString x ^ concatenate xs
    end.

Define compose f g x := f (g x).

Define boolToInt b := if b then 1 else 0.
Define checkToInt := boolToInt âˆ˜ check.
Define showWord word idxs := concatenate (map (\i -> checkToInt { word(i) }) idxs).

Define fst pair :=
    match pair with
    case (a, b) -> a
    end.

Define snd pair :=
    match pair with
    case (a, b) -> b
    end.

