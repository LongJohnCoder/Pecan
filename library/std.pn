#load("bin_add.aut", "hoa", bin_add(a, b, c))
#load("bin_less.aut", "hoa", bin_less(a, b))
#load("odd_ones.aut", "hoa", odd_ones(a))

finite_num(x) := "F(G(!x))"
zero(x) := "G(!x)"

x is any := true
x is nat := finite_num(x)
// binary is, for the moment, a synonym for nat; eventually we may decouple the two
x is binary := finite_num(x)

Restrict x is binary.
bin_even(x) := x is binary & exists y is binary. x = 2*y
bin_odd(x) := x is binary & ¬bin_even(x)
#forget(x)

bin_one(x is binary) := x > 0 & forall b is binary. b > 0 => (x <= b)

default_equal(x, y) := "G((x -> y) & (y -> x))"

#context("adder", "bin_add")
#context("less", "bin_less")
#context("one", "bin_one")
#context("equal", "default_equal")

#type(nat, {
    "adder": bin_add(any, any, any),
    "less": bin_less(any, any),
    "one": bin_one(any),
    "even": bin_even(any),
    "equal": default_equal(any, any),
    "odd": bin_odd(any)
})

#type(binary, {
    "adder": bin_add(any, any, any),
    "less": bin_less(any, any),
    "one": bin_one(any),
    "equal": default_equal(any, any),
    "even": bin_even(any),
    "odd": bin_odd(any)
})

Define enumFromTo low high :=
    if low > high then
        []
    else
        low :: enumFromTo (low + 1) high .

Define map f l :=
    match l with
    case [] -> []
    case x :: xs -> f x :: map f xs
    end.

Define foldl f init l :=
    match l with
    case [] -> init
    case x :: xs -> foldl f (f init x) xs
    end.

Define concatenate xs := foldl (\a b -> a ^ toString b) "" xs.

Define compose f g x := f (g x).

Define boolToInt b := if b then 1 else 0.
Define checkToInt := boolToInt ∘ check.
Define showWord word idxs := concatenate (map (\i -> checkToInt { word(i) }) idxs).

Define fst pair :=
    match pair with
    case (a, b) -> a
    end.

Define snd pair :=
    match pair with
    case (a, b) -> b
    end.

Define theoremCheck ID BODY := do
    emit { ID() := BODY }
    emit { #assert_prop(true, ID) }
    .

Define partialOrderCheck R EQ T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let VAR3 := freshVar in
    let IRREFL_ID := R ^ "_irrefl" in
    let ANTISYM_ID := R ^ "_antisym" in
    let TRANS_ID := R ^ "_trans" in do
        theoremCheck IRREFL_ID { forall VAR1 is T. !R(VAR1, VAR1) }
        theoremCheck ANTISYM_ID { forall VAR1 is T. forall VAR2 is T. if R(VAR1, VAR2) & R(VAR2, VAR1) then EQ(VAR1, VAR2) }
        theoremCheck TRANS_ID { forall VAR1 is T. forall VAR2 is T. forall VAR3 is T. if R(VAR1, VAR2) & R(VAR2, VAR3) then R(VAR1, VAR3) }
    .

Define totalOrderCheck R EQ T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let TOTAL_ID := R ^ "_total" in do
        partialOrderCheck R EQ T
        theoremCheck TOTAL_ID { forall VAR1 is T. forall VAR2 is T. R(VAR1, VAR2) | EQ(VAR1, VAR2) | R(VAR2, VAR1) }
    .

Define equivalenceRelationCheck EQ T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let VAR3 := freshVar in
    let REFL_ID := EQ ^ "_refl" in
    let SYM_ID := EQ ^ "_sym" in
    let TRANS_ID := EQ ^ "_trans" in do
        theoremCheck REFL_ID { forall VAR1 is T. EQ(VAR1, VAR1) }
        theoremCheck SYM_ID { forall VAR1 is T. forall VAR2 is T. EQ(VAR1, VAR2) <=> EQ(VAR2, VAR1) }
        theoremCheck TRANS_ID { forall VAR1 is T. forall VAR2 is T. forall VAR3 is T. if EQ(VAR1, VAR2) & EQ(VAR2, VAR3) then EQ(VAR1, VAR3) }
    .

Define createTypedAdder ADD T :=
    let TYPED_ADDER := freshVar in do
        emit { TYPED_ADDER(x is T, y is T, z is T) := ADD(x, y, z) }
        TYPED_ADDER
    .

Define monoidCheck ADD T :=
    let TYPED_ADDER := createTypedAdder ADD T in
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let VAR3 := freshVar in
    let CLOSED_ID := ADD ^ "_closed" in
    let ASSOC_ID := ADD ^ "_assoc" in
    let ZERO_ID_ID := ADD ^ "_zero_id" in do // Not a typo
        theoremCheck CLOSED_ID { forall VAR1 is T. forall VAR2 is T. exists VAR3 is T. TYPED_ADDER(VAR1, VAR2, VAR3) }
        theoremCheck ASSOC_ID { forall VAR1 is T. forall VAR2 is T. forall VAR3 is T. TYPED_ADDER(VAR1, TYPED_ADDER(VAR2, VAR3)) = TYPED_ADDER(TYPED_ADDER(VAR1, VAR2), VAR3) }
        theoremCheck ZERO_ID_ID { forall VAR1 is T. TYPED_ADDER(VAR1, 0, VAR1) & TYPED_ADDER(0, VAR1, VAR1) }
    .

Define groupCheck ADD T :=
    let TYPED_ADDER := createTypedAdder ADD T in
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let INVERSE_ID := ADD ^ "_inverse" in do
        monoidCheck ADD T
        theoremCheck INVERSE_ID { forall VAR1 is T. exists VAR2 is T. TYPED_ADDER(VAR1, VAR2, 0) }
    .

Define abelianGroupCheck ADD T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let COMM_ID := ADD ^ "_comm" in do
        groupCheck ADD T
        theoremCheck COMM_ID { forall VAR1 is T. forall VAR2 is T. ADD(VAR1, VAR2) = ADD(VAR2, VAR1) }
    .

