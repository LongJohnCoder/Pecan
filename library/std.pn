#load("bin_add.aut", "hoa", bin_add(a, b, c))
#load("bin_less.aut", "hoa", bin_less(a, b))
#load("odd_ones.aut", "hoa", odd_ones(a))

finite_num(x) := "F(G(!x))"
zero(x) := "G(!x)"

x is any := true
x is nat := finite_num(x)
// binary is, for the moment, a synonym for nat; eventually we may decouple the two
x is binary := finite_num(x)

Restrict x is binary.
bin_even(x) := x is binary & exists y is binary. x = 2*y
bin_odd(x) := x is binary & ¬bin_even(x)
#forget(x)

bin_one(x is binary) := x > 0 & forall b is binary. b > 0 => (x <= b)

default_equal(x, y) := "G((x -> y) & (y -> x))"

#context("adder", "bin_add")
#context("less", "bin_less")
#context("one", "bin_one")
#context("equal", "default_equal")

#type(nat, {
    "adder": bin_add(any, any, any),
    "less": bin_less(any, any),
    "one": bin_one(any),
    "even": bin_even(any),
    "equal": default_equal(any, any),
    "odd": bin_odd(any)
})

#type(binary, {
    "adder": bin_add(any, any, any),
    "less": bin_less(any, any),
    "one": bin_one(any),
    "equal": default_equal(any, any),
    "even": bin_even(any),
    "odd": bin_odd(any)
})

Define enumFromTo low high :=
    if low > high then
        []
    else
        low :: enumFromTo (low + 1) high .

Define map f l :=
    match l with
    case [] -> []
    case x :: xs -> f x :: map f xs
    end.

Define foldl f init l :=
    match l with
    case [] -> init
    case x :: xs -> foldl f (f init x) xs
    end.

Define concatenate xs := foldl (\a b -> a ^ toString b) "" xs.

Define compose f g x := f (g x).

Define boolToInt b := if b then 1 else 0.
Define checkToInt := boolToInt ∘ check.
Define showWord word idxs := concatenate (map (\i -> checkToInt { word(i) }) idxs).

Define fst pair :=
    match pair with
    case (a, b) -> a
    end.

Define snd pair :=
    match pair with
    case (a, b) -> b
    end.

Define partialOrderCheck R EQ T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let VAR3 := freshVar in
    let IRREFL_ID := R ^ "_irrefl" in
    let ANTISYM_ID := R ^ "_antisym" in
    let TRANS_ID := R ^ "_trans" in do
        emit { IRREFL_ID() := forall VAR1 is T. !R(VAR1, VAR1) }
        emit { #assert_prop(true, IRREFL_ID) }

        emit { ANTISYM_ID() := forall VAR1 is T. forall VAR2 is T. if R(VAR1, VAR2) & R(VAR2, VAR1) then EQ(VAR1, VAR2) }
        emit { #assert_prop(true, ANTISYM_ID) }

        emit { TRANS_ID() := forall VAR1 is T. forall VAR2 is T. forall VAR3 is T. if R(VAR1, VAR2) & R(VAR2, VAR3) then R(VAR1, VAR3) }
        emit { #assert_prop(true, TRANS_ID) }
    .

Define totalOrderCheck R EQ T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let TOTAL_ID := R ^ "_total" in do
        partialOrderCheck R EQ T

        emit { TOTAL_ID() := forall VAR1 is T. forall VAR2 is T. R(VAR1, VAR2) | EQ(VAR1, VAR2) | R(VAR2, VAR1) }
        emit { #assert_prop(true, TOTAL_ID) }
    .

Define equivalenceRelationCheck EQ T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let VAR3 := freshVar in
    let REFL_ID := EQ ^ "_refl" in
    let SYM_ID := EQ ^ "_sym" in
    let TRANS_ID := EQ ^ "_trans" in do
        emit { REFL_ID() := forall VAR1 is T. EQ(VAR1, VAR1) }
        emit { #assert_prop(true, REFL_ID) }

        emit { SYM_ID() := forall VAR1 is T. forall VAR2 is T. EQ(VAR1, VAR2) <=> EQ(VAR2, VAR1) }
        emit { #assert_prop(true, SYM_ID) }

        emit { TRANS_ID() := forall VAR1 is T. forall VAR2 is T. forall VAR3 is T. if EQ(VAR1, VAR2) & EQ(VAR2, VAR3) then EQ(VAR1, VAR3) }
        emit { #assert_prop(true, TRANS_ID) }
    .

